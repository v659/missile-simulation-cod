import numpy as np
class FinControlSystem:
    """Realistic aerodynamic fin control system with dynamics"""

    def __init__(self, params):
        self.params = params
        self.deflections = np.zeros(4)  # Four fins: up, down, left, right
        self.commanded_deflections = np.zeros(4)
        self.deflection_rates = np.zeros(4)
        self.deflection_accels = np.zeros(4)

        # Fin effectiveness varies with speed (more effective at higher speeds)
        self.speed_factor = 1.0
        self.last_speed = 0.0

    def calculate_commanded_deflections(self, guidance_accel, missile_vel):
        """Calculate commanded fin deflections based on guidance requirements"""
        if np.linalg.norm(missile_vel) < 1e-9:
            return np.zeros(4)

        # Normalize velocity vector
        v_norm = missile_vel / np.linalg.norm(missile_vel)

        # Calculate the required force direction (opposite of guidance_accel for stabilization)
        if np.linalg.norm(guidance_accel) > 1e-9:
            force_dir = -guidance_accel / np.linalg.norm(guidance_accel)
        else:
            force_dir = np.zeros(3)

        # Update speed factor (fins are more effective at higher speeds)
        current_speed = np.linalg.norm(missile_vel)
        if current_speed > 50.0:  # Minimum speed for full effectiveness
            self.speed_factor = min(2.0, current_speed / 100.0)
        else:
            self.speed_factor = 0.5  # Reduced effectiveness at low speeds

        self.last_speed = current_speed

        # Calculate commanded deflections based on required force
        # Fin 0: Up (+Z) - controls pitch up
        self.commanded_deflections[0] = np.dot(force_dir,
                                               np.array([0, 0, 1])) * self.params.fin_max_deflection * self.speed_factor

        # Fin 1: Down (-Z) - controls pitch down
        self.commanded_deflections[1] = -np.dot(force_dir, np.array(
            [0, 0, 1])) * self.params.fin_max_deflection * self.speed_factor

        # Fin 2: Left (-Y when facing forward) - controls yaw left
        self.commanded_deflections[2] = -np.dot(force_dir, np.array(
            [0, 1, 0])) * self.params.fin_max_deflection * self.speed_factor

        # Fin 3: Right (+Y when facing forward) - controls yaw right
        self.commanded_deflections[3] = np.dot(force_dir,
                                               np.array([0, 1, 0])) * self.params.fin_max_deflection * self.speed_factor

        return self.commanded_deflections.copy()

    def update(self, guidance_accel, missile_vel, dt):
        """Update fin deflections based on guidance commands and missile dynamics"""
        # Calculate commanded deflections
        self.calculate_commanded_deflections(guidance_accel, missile_vel)

        # Apply realistic fin dynamics (second-order system with damping and rate limiting)
        for i in range(4):
            # Calculate error between commanded and actual deflection
            error = self.commanded_deflections[i] - self.deflections[i]

            # Second-order dynamics: acceleration = K*error - damping*velocity
            self.deflection_accels[i] = (self.params.fin_effectiveness * error -
                                         2 * self.params.fin_damping * self.deflection_rates[i])

            # Update rates with acceleration
            self.deflection_rates[i] += self.deflection_accels[i] * dt

            # Rate limiting (fins can only move so fast)
            max_rate = self.params.fin_max_deflection / self.params.fin_response_time
            self.deflection_rates[i] = np.clip(self.deflection_rates[i], -max_rate, max_rate)

            # Update deflections with rate
            self.deflections[i] += self.deflection_rates[i] * dt

            # Limit deflections to maximum physical limits
            self.deflections[i] = np.clip(self.deflections[i],
                                          -self.params.fin_max_deflection,
                                          self.params.fin_max_deflection)

            # Add small damping to prevent oscillation
            self.deflection_rates[i] *= 0.95

        return self.deflections.copy()

    def get_fin_forces(self, missile_vel, air_density):
        """Calculate aerodynamic forces generated by fins"""
        if np.linalg.norm(missile_vel) < 1e-9:
            return np.zeros(3)

        # Normalize velocity vector
        v_norm = missile_vel / np.linalg.norm(missile_vel)
        speed = np.linalg.norm(missile_vel)

        # Fin force coefficients (simplified aerodynamics)
        fin_force = np.zeros(3)

        # Up/down fins (pitch control)
        pitch_force = (self.deflections[0] - self.deflections[1]) * 0.5
        fin_force[2] = pitch_force * air_density * speed * speed * 0.01

        # Left/right fins (yaw control)
        yaw_force = (self.deflections[3] - self.deflections[2]) * 0.5
        fin_force[1] = yaw_force * air_density * speed * speed * 0.01

        # Roll control (differential pitch)
        roll_force = (self.deflections[0] + self.deflections[1] -
                      self.deflections[2] - self.deflections[3]) * 0.25
        # Roll would affect angular rates, not directly linear acceleration

        return fin_force

    def get_status(self):
        """Return current fin status for diagnostics"""
        return {
            'deflections': self.deflections.copy(),
            'commanded_deflections': self.commanded_deflections.copy(),
            'rates': self.deflection_rates.copy(),
            'speed_factor': self.speed_factor,
            'effectiveness': self.params.fin_effectiveness * self.speed_factor
        }